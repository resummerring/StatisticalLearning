import numpy as np
import pandas as pd
from statsmodels.tsa.stattools import adfuller


class FractionalDifferentiate:

    """
    General binary expansion:
    (1 - B)^d = \sum_k (-B)^k * \prod_i (d - i) / (k - i) for i = 0 -> k -1 for k = 0 -> inf

    Fractionally differentiate a time series {X(t)}:
    X'(t) = (1 - B)^d X(t) = w * X where w = {1, -d, d(d - 1) / 2!, -d(d - 1)(d - 2) / 3!, ...} and
    X = {X(t), X(t-1), X(t-2), ...}.

    Note that when d = 0 -> X'(t) = X(t), when d = 1 -> X'(t) = X(t) - X(t -1).

    Denote lambda(l) = \sum_j abs(w(j)) for j = T - l to T / \sum_i abs(w(i)) for i from 0 to T - 1,
    representing the relative weight-loss by only taking the first l terms. Since we can never have infinite
    terms, we want the relative weight-loss to be smaller than a threshold \tau.

    Expanding window method:
    Find the smallest l such that lambda(l) <= \tau and lambda(l + 1) > \tau, meaning only using the first l
    terms will incur weight-loss larger than threshold while using the first l + 1 terms will incur weight-loss
    no larger than threshold -> skip the the first l terms and generate the differentiated series from (l + 1)-th
    term with expanding window size from (l + 1) to T.

    Fixed window method:
    Find the smallest l such that |w(l)| >= \tau and |w(l + 1)| < \tau, meaning coefficients after w(l) is not
    significant enough and can be dropped. The differentiated series will always be generated by the first l terms
    with significant coefficient and fixed window size.

    """

    def __init__(self, degree: float, expand_threshold: float, fixed_threshold: float):
        """
        :param degree: float, degrees of fractional differentiation
        :param expand_threshold: float, threshold for expanding window method to generate coefs
        :param fixed_threshold: float, threshold for fixed window method to generate coefs
        """

        self._degree = degree
        self._expand_threshold = expand_threshold
        self._fixed_threshold = fixed_threshold

    # ====================
    #  Private
    # ====================

    def _get_coefs_expanded_window(self, n: int) -> np.ndarray:
        """
        Generate first n-th coefficients from the general binary expansion formula

        :param n: int, number of coefficients to generate
        """

        coefs = [1.]
        for k in range(1, n):
            this_coef = -coefs[-1] / k * (self._degree - k + 1)
            coefs.append(this_coef)

        return np.array(coefs).reshape(-1, 1)

    def _get_coefs_fixed_window(self) -> np.ndarray:
        """
        Generate coefficients that are significant enough in terms of magnitude
        """

        coefs, k = [1.], 1
        while True:
            this_coef = -coefs[-1] / k * (self._degree - k - 1)
            if abs(this_coef) < self._fixed_threshold:
                break
            coefs.append(this_coef)
            k += 1

        return np.array(coefs).reshape(-1, 1)

    # ====================
    #  Public
    # ====================

    @property
    def degree(self):
        """
        Getter degree
        """
        return self._degree

    def set_degree(self, degree: float):
        """
        Setter degree
        """
        self._degree = degree

    def fit_fracdiff_expanding_window(self, series: pd.Series) -> pd.Series:
        """
        Generate fractionally differentiated series with expanding window

        :param series: pd.Series, original time series
        """

        # Determine items to drop based on weight loss
        coefs = self._get_coefs_expanded_window(series.shape[0])
        lambd = np.cumsum(np.abs(coefs[::-1])) / np.cumsum(np.abs(coefs[::-1]))[-1]
        drop = lambd[lambd > self._expand_threshold].shape[0]

        series = series.fillna(method='ffill').dropna()
        output = pd.Series(index=series.index)

        for i in range(drop, series.shape[0]):
            index = series.index[i]
            if not np.isfinite(series[index]):
                continue

            output[index] = np.dot(coefs[: i + 1].T, series[:index]).squeeze()

        return output

    def fit_fracdiff_fixed_window(self, series: pd.Series) -> pd.Series:
        """
        Generate fractionally differentiated series with fixed window

        :param series: pd.Series, original time series
        """

        # Determine significant items to use based on weight magnitude
        coefs = self._get_coefs_fixed_window()
        output = pd.Series(index=series.index)

        series = series.fillna(method='ffill').dropna()
        for idx1 in range(len(coefs), series.shape[0]):
            index0, index1 = series.index[idx1 - len(coefs)], series.index[idx1]
            if not np.isfinite(series[index1]):
                continue

            output[index1] = np.dot(coefs.T, series[index0: index1]).squeeze()

        return output

    def find_min_degree(self, series: pd.Series) -> bool:
        """
        Find the minimum degree such that the resulting fractionally differentiated
        series is stationary with maximum preserved memory. If such degree is not
        found within [0, 1], return False.

        :param series: pd.Series, original time series
        """

        for degree in np.linspace(0.05, 1, 20):

            self.set_degree(degree)
            series_degree = self.fit_fracdiff_fixed_window(series)
            p_value = adfuller(series_degree)[1]
            if p_value < 0.05:
                return True

        return False
